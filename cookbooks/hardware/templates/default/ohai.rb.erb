require "pathname"

Ohai.plugin(:Hardware) do
  provides "hardware"

  def read_sysctl_link(file)
    File.basename(File.readlink(file))
  rescue Errno::ENOENT, Errno::ENOTDIR
  end

  def read_sysctl_file(file)
    IO.read(file).strip
  rescue Errno::ENOENT, Errno::ENOTDIR, Errno::EINVAL
  end

  def parse_memory_size(size)
    if size =~ /^(\d+(?:\.\d+)?)\s*TB/i
      Regexp.last_match(1).to_f * 2**30
    elsif size =~ /^(\d+(?:\.\d+)?)\s*GB/i
      Regexp.last_match(1).to_f * 2**20
    elsif size =~ /^(\d+(?:\.\d+)?)\s*MB/i
      Regexp.last_match(1).to_f * 2**10
    end
  end

  def format_disk_size(kb)
    if kb == 0
      ""
    else
      kblog10 = Math.log10(kb).floor

      kb = kb.to_f * 2 / 10**kblog10
      kb = kb.round.to_f / 2

      if kblog10 >= 9
        format "%gTB", kb * 10**(kblog10 - 9)
      elsif kblog10 >= 6
        format "%dGB", kb * 10**(kblog10 - 6)
      else
        format "%dMB", kb * 10**(kblog10 - 3)
      end
    end
  end

  def memory_to_disk_size(size)
    format_disk_size(parse_memory_size(size))
  end

  def find_sas_device(address)
    file = Dir.glob("/sys/class/scsi_generic/sg*/device/sas_address").find do |file|
      read_sysctl_file(file) == "0x#{address}"
    end

    if file
      dir = File.dirname(file)
      device = Dir.glob("#{dir}/block/*").first ||
               Dir.glob("#{dir}/scsi_generic/*").first

      "/dev/#{File.basename(device)}"
    end
  end

  def pci_devices
    devices = {}
    device = nil

    IO.popen(["lspci", "-Dkvmm"]).each do |line|
      if line =~ /^Slot:\s+((\h{4}):(\h{2}):(\h{2}).(\h))\s*$/
        device = {
          :slot => Regexp.last_match(1),
          :domain => Regexp.last_match(2),
          :bus => Regexp.last_match(3),
          :device => Regexp.last_match(4),
          :function => Regexp.last_match(5)
        }
      elsif device && line =~ /^([A-Z]+):\s+(.*)\s*$/i
        case Regexp.last_match(1)
        when "Class" then device[:class_name] = Regexp.last_match(2)
        when "Vendor" then device[:vendor_name] = Regexp.last_match(2)
        when "Device" then device[:device_name] = Regexp.last_match(2)
        when "SVendor" then device[:subsystem_vendor_name] = Regexp.last_match(2)
        when "SDevice" then device[:subsystem_device_name] = Regexp.last_match(2)
        when "PhySlot" then device[:physical_slot] = Regexp.last_match(2)
        when "Rev" then device[:revision] = Regexp.last_match(2)
        when "ProgIf" then device[:programming_interface] = Regexp.last_match(2)
        when "Driver" then device[:driver] = Regexp.last_match(2)
        when "Module" then device[:modules] = Array(device[:modules]) << Regexp.last_match(2)
        end
      elsif device && line =~ /^\s*$/
        devices[device[:slot]] = device
        device = nil
      end
    end

    IO.popen(["lspci", "-Dkvmmn"]).each do |line|
      if line =~ /^Slot:\s+((\h{4}):(\h{2}):(\h{2}).(\h))\s*$/
        device = devices[Regexp.last_match(1)]
      elsif device && line =~ /^([A-Z]+):\s+(.*)\s*$/i
        case Regexp.last_match(1)
        when "Class" then device[:class_id] = Regexp.last_match(2)
        when "Vendor" then device[:vendor_id] = Regexp.last_match(2)
        when "Device" then device[:device_id] = Regexp.last_match(2)
        when "SVendor" then device[:subsystem_vendor_id] = Regexp.last_match(2)
        when "SDevice" then device[:subsystem_device_id] = Regexp.last_match(2)
        end
      elsif device && line =~ /^\s*$/
        device = nil
      end
    end

    devices
  end

  def network_devices
    Dir.glob("/sys/class/net/*").each_with_object(Mash.new) do |device, devices|
      name = File.basename(device)

      devices[name] = {
        :device => read_sysctl_link("#{device}/device"),
        :duplex => read_sysctl_file("#{device}/duplex"),
        :speed => read_sysctl_file("#{device}/speed")
      }.delete_if { |_, v| v.nil? }
    end
  end

  def memory_devices
    device = nil

    IO.popen(["dmidecode", "-t", "memory"]).each_with_object([]) do |line, devices|
      if line =~ /^Memory Device\s*$/
        device = {}
      elsif device && line =~ /^\s+([A-Z ]+):\s+(.*)\s*$/i
        device[Regexp.last_match(1).tr(" ", "_").downcase.to_sym] = Regexp.last_match(2).strip
      elsif device && line =~ /^\s*$/
        devices << device
        device = nil
      end
    end
  end

  def disk_devices
    disk = Mash.new

    disk[:controllers] = []
    disk[:arrays] = []
    disk[:disks] = []

    find_direct_disks(disk)
    find_nvme_disks(disk)

    find_hp_disks(disk) if File.exist?("/usr/sbin/ssacli")
    find_megaraid_disks(disk) if File.exist?("/usr/sbin/megacli")
    find_mpt1_disks(disk) if File.exist?("/usr/sbin/lsiutil")
    find_mpt2_disks(disk) if File.exist?("/usr/sbin/sas2ircu")
    find_adaptec_disks(disk) if File.exist?("/usr/sbin/arcconf")
    find_areca_disks(disk) if File.exist?("/opt/areca/x86_64/cli64")

    find_md_arrays(disk)

    disk[:disks].each do |disk|
      if disk[:vendor] =~ /^(BTWA|CVPR|PHDV)/ && disk[:model] == "INTEL"
        disk[:model] = disk[:serial_number]
        disk[:serial_number] = disk[:vendor]
        disk[:vendor] = "INTEL"
      end

      if disk[:vendor].nil? && disk[:model] =~ /^ATA\s+(.*)$/
        disk[:vendor] = "ATA"
        disk[:model] = Regexp.last_match(1)
      end

      if disk[:vendor].nil? || disk[:vendor] == "ATA"
        if disk[:model] =~ /^(\S+)\s+(.*)$/
          disk[:vendor] = Regexp.last_match(1)
          disk[:model] = Regexp.last_match(2)
        elsif disk[:model] =~ /^ST/
          disk[:vendor] = "SEAGATE"
        elsif disk[:model] =~ /^C300-(.*)$/
          disk[:vendor] = "CRUCIAL"
          disk[:model] = Regexp.last_match(1)
        end
      end

      disk[:model].sub!(/-.*$/, "") if disk[:model]
    end

    disk
  end

  def find_direct_disks(devices)
    Dir.glob("/sys/class/scsi_host/host*") do |host|
      driver = read_sysctl_file("#{host}/proc_name")

      if %w(ahci mptsas sata_mv sata_nv).include?(driver)
        bus = host.sub("/sys/class/scsi_host/host", "")

        Dir.glob("/sys/bus/scsi/devices/#{bus}:0:*").each do |device|
          next unless File.exist?("#{device}/scsi_disk")

          block = Dir.glob("#{device}/block/*").first
          size = read_sysctl_file("#{block}/size").to_f / 2

          devices[:disks] << {
            :id => devices[:disks].count,
            :device => "/dev/#{File.basename(block)}",
            :vendor => read_sysctl_file("#{device}/vendor"),
            :model => read_sysctl_file("#{device}/model"),
            :firmware_version => read_sysctl_file("#{device}/rev"),
            :size => format_disk_size(size),
            :arrays => []
          }
        end
      end
    end
  end

  def find_nvme_disks(devices)
    Dir.glob("/sys/class/nvme/nvme*") do |device|
      controller = {
        :id => devices[:controllers].count,
        :pci_slot => File.basename(Pathname.new("#{device}/device").realpath),
        :arrays => [],
        :disks => []
      }

      devices[:controllers] << controller

      IO.popen(["lspci", "-Dkvmm", "-s", controller[:pci_slot]]).each do |line|
        if line =~ /^SVendor:\s+(\S.*\S)\s*$/
          controller[:vendor] = Regexp.last_match(1)
        elsif line =~ /^SDevice:\s+(\S.*\S)\s*$/
          controller[:model] = Regexp.last_match(1)
        end
      end

      Dir.glob("#{device}/nvme*").each do |block|
        size = read_sysctl_file("#{block}/size").to_f / 2

        disk = {
          :id => devices[:disks].count,
          :controller => controller[:id],
          :device => "/dev/#{File.basename(block)}",
          :vendor => controller[:vendor],
          :model => controller[:model],
          :size => format_disk_size(size),
          :arrays => []
        }

        devices[:disks] << disk
        controller[:disks] << disk[:id]
      end
    end
  end

  def find_md_arrays(devices)
    array = nil

    File.new("/proc/mdstat", "r").each do |line|
      if line =~ /^(md\d+) : active raid(\d+)((?: (?:sd[a-z]\d*|nvme\d+n\d+(?:p\d+)?)\[\d+\](?:\([A-Z]\))*)+)$/
        array = {
          :id => devices[:arrays].count,
          :device => "/dev/#{Regexp.last_match(1)}",
          :status => "optimal",
          :raid_level => Regexp.last_match(2),
          :disks => []
        }

        Regexp.last_match(3).split(" ").each do |member|
          if member =~ /^(sd[a-z]+|nvme\d+n\d+).*/
            device = Regexp.last_match(1)

            if disk = devices[:disks].find { |d| d[:device] == "/dev/#{device}" }
              if member =~ /\(F\)/
                disk[:status] = "failed"
              elsif member =~ /\(S\)/
                disk[:status] = "hotspare"
              else
                disk[:status] = "online"
              end

              disk[:arrays] << array[:id]
              array[:disks] << disk[:id]
            end
          end
        end

        devices[:arrays] << array
      elsif array && line =~ /^\s+(\d+) blocks.*(?:\[([U_]+)\])?/
        array[:size] = format_disk_size(Regexp.last_match(1).to_i)
        array[:status] = "degraded" if Regexp.last_match(2) =~ /_/
      elsif array && line =~ /^\s+\[.*\]\s+(\S+)\s+=/
        case Regexp.last_match(1)
        when "recovery" then array[:status] = "rebuilding"
        when "resync" then array[:status] = "rebuilding"
        when "checking" then array[:status] = "checking"
        end
      end
    end
  end

  def find_hp_disks(devices)
    controllers = []
    disks = []

    controller = nil
    array = nil
    disk = nil

    IO.popen(%w(ssacli controller all show config detail)).each do |line|
      next unless line.valid_encoding?

      if line =~ /^Smart (?:Array|HBA) (\S+) /
        controller = {
          :id => devices[:controllers].count,
          :type => "hp",
          :model => Regexp.last_match(1),
          :arrays => [],
          :disks => []
        }

        devices[:controllers] << controller

        controllers << controller

        array = nil
        disk = nil
      elsif controller && line =~ /^   (\S.*):\s+(.*)$/
        case Regexp.last_match(1)
        when "Slot" then controller[:slot] = Regexp.last_match(2)
        when "Serial Number" then controller[:serial_number] = Regexp.last_match(2)
        when "Hardware Revision" then controller[:hardware_version] = Regexp.last_match(2)
        when "Firmware Version" then controller[:firmware_version] = Regexp.last_match(2)
        when "PCI Address (Domain:Bus:Device.Function)" then controller[:pci_slot] = Regexp.last_match(2)
        when "Battery/Capacitor Status" then controller[:battery_status] = Regexp.last_match(2).split.first.downcase
        end
      elsif controller && line =~ /^      Logical Drive: (\d+)$/
        array = {
          :id => devices[:arrays].count,
          :controller => controller[:id],
          :number => Regexp.last_match(1),
          :disks => []
        }

        devices[:arrays] << array
        controller[:arrays] << array[:id]

        disk = nil
      elsif array && line =~ /^      physicaldrive (\S+)$/
        disk = {
          :id => devices[:disks].count,
          :controller => controller[:id],
          :arrays => [array[:id]],
          :location => Regexp.last_match(1)
        }

        devices[:disks] << disk
        controller[:disks] << disk[:id]
        array[:disks] << disk[:id]
      elsif disk && line =~ /^         (\S[^:]+):\s+(.*\S)\s*$/
        case Regexp.last_match(1)
        when "Status" then disk[:status] = Regexp.last_match(2)
        when "Drive Type" then disk[:drive_type] = Regexp.last_match(2)
        when "Interface Type" then disk[:interface] = Regexp.last_match(2)
        when "Size" then disk[:size] = Regexp.last_match(2)
        when "Rotational Speed" then disk[:rpm] = Regexp.last_match(2)
        when "Firmware Revision" then disk[:firmware_version] = Regexp.last_match(2)
        when "Serial Number" then disk[:serial_number] = Regexp.last_match(2)
        when "Model" then disk[:model] = Regexp.last_match(2)
        end
      elsif array && line =~ /^         Status:\s+(.*\S)\s*$/
        case Regexp.last_match(1)
        when "OK" then array[:status] = "optimal"
        when "Interim Recovery Mode" then array[:status] = "degraded"
        else array[:status] = "unknown"
        end
      elsif array && line =~ /^         (\S[^:]+):\s+(.*\S)\s*$/
        case Regexp.last_match(1)
        when "Size" then array[:size] = Regexp.last_match(2)
        when "Fault Tolerance" then array[:raid_level] = Regexp.last_match(2)
        when "Status" then array[:status] = Regexp.last_match(2)
        when "Disk Name" then array[:device] = Regexp.last_match(2).strip
        when "Mount Points" then array[:mount_point] = Regexp.last_match(2).split.first
        when "Unique Identifier" then array[:wwn] = Regexp.last_match(2)
        end
      end
    end

    controllers.each do |controller|
      slot = controller[:slot]

      IO.popen(%W(ssacli controller slot=#{slot} pd all show status)).each do |line|
        if line =~ /^   physicaldrive (\S+) /
          disks << Regexp.last_match(1)
        end
      end

      if device = Dir.glob("/sys/bus/pci/devices/#{controller[:pci_slot]}/cciss*").first
        controller[:device] = File.basename(device).sub(/^cciss(\d+)$/, "/dev/cciss/c\\1d0")
      elsif device = Dir.glob("/sys/bus/pci/devices/#{controller[:pci_slot]}/host*/target*:3:0/*:3:0:0/scsi_generic/sg*").first
        controller[:device] = "/dev/#{File.basename(device)}"
      elsif device = Dir.glob("/sys/bus/pci/devices/#{controller[:pci_slot]}/host*/target*:1:0/*:1:0:*/scsi_generic/sg*").first
        controller[:device] = "/dev/#{File.basename(device)}"
      end
    end

    devices[:disks].each do |disk|
      controller = disk[:controller]

      next unless devices[:controllers][controller][:type] == "hp"

      disk[:smart_device] = "cciss,#{disks.find_index(disk[:location])}"

      if disk[:status] == "Failed"
        disk[:status] = "failed"
      elsif disk[:status] == "Predictive Failure"
        disk[:status] = "failed"
      elsif disk[:status] == "OK" && disk[:drive_type] == "Data Drive"
        disk[:status] = "online"
      elsif disk[:status] == "OK" && disk[:drive_type] == "Spare Drive"
        disk[:status] = "hotspare"
      elsif disk[:drive_type] == "Unassigned Drive"
        disk[:status] = "unconfigured"
      else
        disk[:status] = "unknown"
      end

      disk.delete(:drive_type)
    end
  end

  def find_megaraid_disks(devices)
    controllers = []
    arrays = []
    disks = []

    controller = nil
    array = nil
    disk = nil

    IO.popen(%w(megacli -AdpGetPciInfo -aAll -NoLog)).each do |line|
      if line =~ /^PCI information for Controller (\d+)$/
        controller = {
          :id => devices[:controllers].count,
          :type => "megaraid",
          :arrays => [],
          :disks => []
        }

        devices[:controllers] << controller

        controllers << controller
      elsif line =~ /^Bus Number\s+:\s+([0-9a-f]+)$/i
        controller[:pci_slot] = format "0000:%02x", Integer("0x#{Regexp.last_match(1)}")
      elsif line =~ /^Device Number\s+:\s+([0-9a-f]+)$/i
        controller[:pci_slot] = format "%s:%02x", controller[:pci_slot], Integer("0x#{Regexp.last_match(1)}")
      elsif line =~ /^Function Number\s+:\s+([0-9a-f]+)$/i
        controller[:pci_slot] = format "%s.%01x", controller[:pci_slot], Integer("0x#{Regexp.last_match(1)}")
      end
    end

    IO.popen(%w(megacli -AdpAllInfo -aAll -NoLog)).each do |line|
      if line =~ /^Adapter #(\d+)$/
        controller = controllers[Regexp.last_match(1).to_i]
      elsif line =~ /^(\S.*\S)\s*:\s+(\S.*)$/
        case Regexp.last_match(1)
        when "Product Name" then controller[:model] = Regexp.last_match(2)
        when "Serial No" then controller[:serial_number] = Regexp.last_match(2)
        when "FW Package Build" then controller[:firmware_version] = Regexp.last_match(2)
        end
      end
    end

    IO.popen(%w(megacli -LdPdInfo -aAll -NoLog)).each do |line|
      if line =~ /^Adapter #(\d+)$/
        controller = controllers[Regexp.last_match(1).to_i]
      elsif controller && line =~ /^Virtual Drive: (\d+) \(Target Id: (\d+)\)$/
        pci_slot = controller[:pci_slot]
        target = Regexp.last_match(2)
        device = Dir.glob("/sys/bus/pci/devices/#{pci_slot}/host*/target*:2:#{target}/*:2:#{target}:0/block/*").first

        array = {
          :id => devices[:arrays].count,
          :controller => controller[:id],
          :number => Regexp.last_match(1),
          :device => "/dev/#{File.basename(device)}",
          :disks => []
        }

        devices[:arrays] << array
        controller[:arrays] << array[:id]

        arrays << array

        disk = nil
      elsif array && line =~ /^PD: (\d+) Information$/
        disk = {
          :id => devices[:disks].count,
          :controller => controller[:id],
          :arrays => [array[:id]]
        }

        devices[:disks] << disk
        controller[:disks] << disk[:id]
        array[:disks] << disk[:id]

        disks << disk
      elsif disk && line =~ /^Firmware state:\s+(\S.*)$/
        status, state = Regexp.last_match(1).split(/,\s*/)
        case status
        when "Unconfigured(good)" then disk[:status] = "unconfigured"
        when "Unconfigured(bad)" then disk[:status] = "unconfigured"
        when "Hotspare" then disk[:status] = "hotspare"
        when "Offline" then disk[:status] = "offline"
        when "Online" then disk[:status] = "online"
        when "Rebuild" then disk[:status] = "rebuilding"
        when "Failed" then disk[:status] = "failed"
        when "Copyback" then disk[:status] = "rebuilding"
        else disk[:status] = "unknown"
        end
        case state
        when "Spun Up" then disk[:state] = "spun_up"
        when "Spun down" then disk[:state] = "spun_down"
        else disk[:state] = "unknown"
        end
      elsif disk && line =~ /^(\S.*\S)\s*:\s+(\S.*)$/
        case Regexp.last_match(1)
        when "Device Id" then disk[:device_id] = Regexp.last_match(2)
        when "WWN" then disk[:wwn] = Regexp.last_match(2)
        when "PD Type" then disk[:interface] = Regexp.last_match(2)
        when "Raw Size" then disk[:size] = memory_to_disk_size(Regexp.last_match(2).sub(/\s*\[.*\]$/, ""))
        when "Inquiry Data" then disk[:vendor], disk[:model], disk[:serial_number] = Regexp.last_match(2).split
        end
      elsif array && line =~ /^State\s*:\s+(.*\S)\s*$/
        case Regexp.last_match(1)
        when "Partially Degraded" then array[:status] = "degraded"
        when "Degraded" then array[:status] = "degraded"
        when "Optimal" then array[:status] = "optimal"
        when "Consistency Check" then array[:status] = "checking"
        when "Background Initialization" then array[:status] = "initialising"
        when "Initialization" then array[:status] = "initialising"
        when "Reconstruction" then array[:status] = "rebuilding"
        else array[:status] = "unknown"
        end
      elsif array && line =~ /^(\S.*\S)\s*:\s+(\S.*)$/
        case Regexp.last_match(1)
        when "RAID Level" then array[:raid_level] = Regexp.last_match(2).scan(/Primary-(\d+)/).first.first
        when "Size" then array[:size] = Regexp.last_match(2)
        end
      end
    end

    IO.popen(%w(megacli -PDList -aAll -NoLog)).each do |line|
      if line =~ /^Adapter #(\d+)$/
        controller = controllers[Regexp.last_match(1).to_i]
      elsif controller && line =~ /^Enclosure Device ID: \d+$/
        disk = {
          :controller => controller[:id],
          :arrays => []
        }
      elsif disk && line =~ /^WWN:\s+(\S+)$/
        unless devices[:disks].find { |d| d[:wwn] == Regexp.last_match(1) }
          disk[:id] = devices[:disks].count
          disk[:wwn] = Regexp.last_match(1)

          devices[:disks] << disk

          disks << disk
        end
      elsif disk && line =~ /^Firmware state:\s+(\S.*)$/
        status, state = Regexp.last_match(1).split(/,\s*/)
        case status
        when "Unconfigured(good)" then disk[:status] = "unconfigured"
        when "Unconfigured(bad)" then disk[:status] = "unconfigured"
        when "Hotspare" then disk[:status] = "hotspare"
        when "Offline" then disk[:status] = "offline"
        when "Online" then disk[:status] = "online"
        when "Rebuild" then disk[:status] = "rebuilding"
        when "Failed" then disk[:status] = "failed"
        when "Copyback" then disk[:status] = "rebuilding"
        else disk[:status] = "unknown"
        end
        case state
        when "Spun Up" then disk[:state] = "spun_up"
        when "Spun down" then disk[:state] = "spun_down"
        else disk[:state] = "unknown"
        end
      elsif disk && line =~ /^(\S.*\S)\s*:\s+(\S.*)$/
        case Regexp.last_match(1)
        when "Device Id" then disk[:device_id] = Regexp.last_match(2)
        when "PD Type" then disk[:interface] = Regexp.last_match(2)
        when "Raw Size" then disk[:size] = memory_to_disk_size(Regexp.last_match(2).sub(/\s*\[.*\]$/, ""))
        when "Inquiry Data" then disk[:vendor], disk[:model], disk[:serial_number] = Regexp.last_match(2).split
        end
      end
    end

    controllers.each do |controller|
      if device = Dir.glob("/sys/bus/pci/devices/#{controller[:pci_slot]}/host*/target*:2:0/*/scsi_generic/sg*").first
        controller[:device] = "/dev/#{File.basename(device)}"
      end
    end

    disks.each do |disk|
      controller = devices[:controllers][disk[:controller]]

      if id = disk.delete(:device_id)
        if device = Dir.glob("/sys/bus/pci/devices/#{controller[:pci_slot]}/host*/target0:0:#{id}/0:0:#{id}:0/block/sd*").first
          disk[:device] = "/dev/#{File.basename(device)}"
        else
          disk[:smart_device] = "megaraid,#{id}"
        end
      end
    end
  end

  def find_mpt1_disks(devices)
    controllers = []
    disks = []

    controller = nil

    IO.popen(%w(lsiutil -s)).each do |line|
      if line =~ /^\/proc\/mpt\/ioc(\d+)\s+LSI Logic\s+(\S+)\s+/
        controller = {
          :id => devices[:controllers].count,
          :type => "mpt1",
          :model => Regexp.last_match(1),
          :arrays => [],
          :disks => []
        }

        controllers << controller
        devices[:controllers] << controller
      elsif line =~ /^\s+(\d+)\s+(\d+)\s+PhysDisk (\d+)\s+(\S+)\s+(\S+)\s+\d+\s+(\S+)\s+/
        disks[Regexp.last_match(3).to_i] = {
          :id => devices[:disks].count,
          :controller => controller[:id],
          :vendor => Regexp.last_match(4),
          :model => Regexp.last_match(5),
          :sas_address => Regexp.last_match(6),
          :arrays => []
        }

        controller[:disks] << devices[:disks].count
        devices[:disks] << disks[Regexp.last_match(3).to_i]
      end
    end

    controllers.each_with_index do |controller, index|
      port = index + 1
      array = nil

      IO.popen(["lsiutil", "-p", port.to_s, "-a", "69,0"]).each do |line|
        if line =~ /^ (\d+)\s+(\d+)\s+(\d+)\s+(\d+)\s+RAID/
          seg = Regexp.last_match(1).to_i
          bus = Regexp.last_match(2).to_i
          dev = Regexp.last_match(3).to_i
          fun = Regexp.last_match(4).to_i

          controller[:pci_slot] = sprintf("%04x:%02x:%02x.%01x", seg, bus, dev, fun)
        end
      end

      IO.popen(["lsiutil", "-p", port.to_s, "-a", "21,1,0,0"]).each do |line|
        if line =~ /^Volume (\d+) is/
          array = {
            :id => devices[:arrays].count,
            :controller => controller[:id],
            :number => Regexp.last_match(1),
            :disks => []
          }

          devices[:arrays] << array
          controller[:arrays] << array[:id]
        elsif line =~ /^  Member \d+ is PhysDisk (\d+) /
          array[:disks] << disks[Regexp.last_match(1).to_i][:id]
          disks[Regexp.last_match(1).to_i][:arrays] << array[:id]
        end
      end
    end

    disks.each do |disk|
      slot = controllers[disk[:controller]][:pci_slot]
      sas_address = "0x#{disk[:sas_address]}"

      Dir.glob("/sys/bus/pci/devices/#{slot}/host*/port-*:*/end_device-*:*/sas_device/end_device-*:*").each do |sas_device|
        if read_sysctl_file("#{sas_device}/sas_address") == sas_address
          if device = Dir.glob("#{sas_device}/device/target*:0:*/*:0:*:0/scsi_generic/sg*").first
            disk[:device] = "/dev/#{File.basename(device)}"            
          end
        end
      end
    end
  end

  def find_mpt2_disks(devices)
    controllers = []

    IO.popen(%w(sas2ircu list)).each do |line|
      next unless line =~ /^\s+(\d+)\s+(\S+)\s+\h+h\s+\h+h\s+(\S+)\s+\h+h\s+\h+h\s*$/
      controllers[Regexp.last_match(1).to_i] = {
        :id => devices[:controllers].count,
        :type => "mpt2",
        :model => Regexp.last_match(2),
        :pci_slot => Regexp.last_match(3).sub(/^(\h{2})h:(\h{2})h:(\h{2})h:0(\h)h$/, "00\\1:\\2:\\3.\\4"),
        :arrays => [],
        :disks => []
      }

      devices[:controllers] << controllers[Regexp.last_match(1).to_i]
    end

    controllers.each_with_index do |controller, index|
      arrays = []
      disks = []

      array = nil
      disk = nil

      IO.popen(["sas2ircu", index.to_s, "display"]).each do |line|
        if line =~ /^IR volume (\d+)$/
          array = {
            :id => devices[:arrays].count,
            :controller => controller[:id],
            :number => Regexp.last_match(1),
            :disks => []
          }

          devices[:arrays] << array
          controller[:arrays] << array[:id]

          arrays << array
        elsif line =~ /^Device is a Hard disk$/
          disk = {
            :id => devices[:disks].count,
            :controller => controller[:id],
            :arrays => []
          }

          devices[:disks] << disk
          controller[:disks] << disk[:id]

          disks << disk
        elsif disk && line =~ /^  State\s+:\s+(.*\S)\s*$/
          Regexp.last_match(1).split(/,\s*/).each do |state|
            case state
            when "Online (ONL)" then disk[:status] = "online"
            when "Hot Spare (HSP)" then disk[:status] = "hotspare"
            when "Ready (RDY)" then disk[:status] = "unconfigured"
            when "Available (AVL)" then disk[:status] = "unconfigured"
            when "Failed (FLD)" then disk[:status] = "failed"
            when "Missing (MIS)" then disk[:status] = "missing"
            when "Standby (SBY)" then disk[:status] = "unconfigured"
            when "Out of Sync (OSY)" then disk[:status] = "degraded"
            when "Degraded (DGD)" then disk[:status] = "degraded"
            when "Rebuilding (RBLD)" then disk[:status] = "rebuilding"
            when "Optimal (OPT)" then disk[:status] = "online"
            else disk[:status] = "unknown"
            end
          end
        elsif disk && line =~ /^  (\S.*\S)\s+:\s+(.*\S)\s*$/
          case Regexp.last_match(1)
          when "Enclosure #" then disk[:location] = Regexp.last_match(2)
          when "Slot #" then disk[:location] = "#{disk[:location]}:#{Regexp.last_match(2)}"
          when "SAS Address" then disk[:device] = find_sas_device(Regexp.last_match(2).tr("-", ""))
          when "Size (in MB)/(in sectors)" then disk[:size] = memory_to_disk_size("#{Regexp.last_match(2).split('/').first} MB")
          when "Manufacturer" then disk[:vendor] = Regexp.last_match(2)
          when "Model Number" then disk[:model] = Regexp.last_match(2)
          when "Firmware Revision" then disk[:firmware_version] = Regexp.last_match(2)
          when "Serial Number" then disk[:serial_number] = Regexp.last_match(2)
          when "Protocol" then disk[:interface] = Regexp.last_match(2)
          end
        elsif array && line =~ /^  PHY\[\d+\] Enclosure#\/Slot#\s+:\s+(\d+:\d+)\s*$/
          array[:disks] << Regexp.last_match(1)
        elsif array && line =~ /^  Status of volume\s+:\s+(.*\S)\s*$/
          Regexp.last_match(1).split(/,\s*/).each do |state|
            case state
            when "Okay (OKY)" then array[:status] = "optimal"
            when "Degraded (DGD)" then array[:status] = "degraded"
            when "Failed (FLD)" then array[:status] = "failed"
            when "Missing (MIS)" then array[:status] = "missing"
            when "Initializing (INIT)" then array[:status] = "initialising"
            when "Online (ONL)" then array[:status] = "optimal"
            else array[:status] = "unknown"
            end
          end
        elsif array && line =~ /^  (\S.*\S)\s+:\s+(.*\S)\s*$/
          case Regexp.last_match(1)
          when "Volume wwid" then array[:device] = find_sas_device(Regexp.last_match(2))
          when "RAID level" then array[:raid_level] = Regexp.last_match(2).sub(/^RAID/, "")
          when "Size (in MB)" then array[:size] = "#{Regexp.last_match(2)} MB"
          end
        elsif line =~ /^  (\S.*\S)\s+:\s+(.*\S)\s*$/
          case Regexp.last_match(1)
          when "BIOS version" then controller[:bios_version] = Regexp.last_match(2)
          when "Firmware version" then controller[:firmware_version] = Regexp.last_match(2)
          end
        end
      end

      arrays.each do |array|
        array[:disks].map! do |location|
          disk = disks.find { |disk| disk[:location] == location }

          disk[:arrays] << array[:id]
          disk[:id]
        end
      end
    end
  end

  def find_adaptec_disks(devices)
    controller_count = IO.popen(%w(arcconf getconfig 0)).first.scan(/^Controllers Found: (\d+)$/i).first.first.to_i

    1.upto(controller_count).each do |controller_number|
      controller = {
        :id => devices[:controllers].count,
        :number => controller_number,
        :type => "adaptec",
        :arrays => [],
        :disks => []
      }

      devices[:controllers] << controller

      arrays = []
      disks = []

      array = nil
      disk = nil

      IO.popen(["arcconf", "getconfig", controller_number.to_s]).each do |line|
        if line =~ /^Logical Device Number (\d+)$/i
          array = {
            :id => devices[:arrays].count,
            :controller => controller[:id],
            :number => Regexp.last_match(1).to_i,
            :disks => []
          }

          devices[:arrays] << array
          controller[:arrays] << array[:id]

          arrays << array
        elsif line =~ /^      Device #(\d+)$/
          disk = nil
        elsif line =~ /^         Device is a Hard drive$/
          disk = {
            :id => devices[:disks].count,
            :controller => controller[:id],
            :arrays => []
          }

          devices[:disks] << disk
          controller[:disks] << disk[:id]

          disks << disk
        elsif disk && line =~ /^         Reported Channel,Device\(T:L\)\s*:\s+(\d+),(\d+)\(\d+:0\)\s*$/
          disk[:channel_number] = Regexp.last_match(1)
          disk[:device_number] = Regexp.last_match(2)
        elsif disk && line =~ /^         State\s*:\s+(\S.*\S)\s*$/
          case Regexp.last_match(1)
          when "Online" then disk[:status] = "online"
          when "Online (JBOD)" then disk[:status] = "online"
          when "Hot Spare" then disk[:status] = "hotspare"
          when "Ready" then disk[:status] = "unconfigured"
          when "Global Hot-Spare" then disk[:status] = "hostspare"
          when "Dedicated Hot-Spare" then disk[:status] = "hotspare"
          else disk[:status] = "unknown"
        end
        elsif disk && line =~ /^         (\S.*\S)\s*:\s+(\S.*\S)\s*$/
          case Regexp.last_match(1)
          when "Reported Location" then disk[:location] = Regexp.last_match(2)
          when "Vendor" then disk[:vendor] = Regexp.last_match(2)
          when "Model" then disk[:model] = Regexp.last_match(2)
          when "Firmware" then disk[:firmware_version] = Regexp.last_match(2)
          when "Serial number" then disk[:serial_number] = Regexp.last_match(2)
          when "Serial Number" then disk[:serial_number] = Regexp.last_match(2)
          when "World-wide name" then disk[:wwn] = Regexp.last_match(2)
          when "World-wide Name" then disk[:wwn] = Regexp.last_match(2)
          when "Total Size" then disk[:size] = memory_to_disk_size(Regexp.last_match(2))
          when "Size" then disk[:size] = memory_to_disk_size(Regexp.last_match(2))
          end
        elsif array && line =~ / Present \(.*((?:Connector|Enclosure):\d+,\s*(?:Device|Slot):\d+)\) /
          array[:disks] << Regexp.last_match(1).tr(":", " ").gsub(/,\s*/, ", ")
        elsif array && line =~ /^   Status of Logical Device\s*:\s+(\S.*\S)\s*$/
          case Regexp.last_match(1)
          when "Optimal" then array[:status] = "optimal"
          else array[:status] = "unknown"
        end
        elsif array && line =~ /^   (\S.*\S)\s*:\s+(\S.*\S)\s*$/
          case Regexp.last_match(1)
          when "RAID level" then array[:raid_level] = Regexp.last_match(2)
          when "RAID Level" then array[:raid_level] = Regexp.last_match(2)
          when "Size" then array[:size] = memory_to_disk_size(Regexp.last_match(2))
          end
        elsif line =~ /^   (\S.*\S)\s*:\s+(\S.*\S)\s*$/
          case Regexp.last_match(1)
          when "Controller Model" then controller[:model] = Regexp.last_match(2)
          when "Controller Serial Number" then controller[:serial_number] = Regexp.last_match(2)
          when "Controller World Wide Name" then controller[:wwn] = Regexp.last_match(2)
          when "BIOS" then controller[:bios_version] = Regexp.last_match(2)
          when "Firmware" then controller[:firmware_version] = Regexp.last_match(2)
          end
        elsif line =~ /^         Serial Number\s*:\s+(\S.*\S)\s*$/
          controller[:serial_number] = Regexp.last_match(1)
        end
      end

      host = Dir.glob("/sys/class/scsi_host/host*").find do |host|
        read_sysctl_file("#{host}/serial_number") == controller[:serial_number]
      end

      arrays.each do |array|
        array_number = array[:number]
        device = Dir.glob("#{host}/device/target*:0:#{array_number}/*:0:#{array_number}:0/block/*").first

        array[:device] = "/dev/#{File.basename(device)}"

        array[:disks].map! do |location|
          disk = disks.find { |disk| disk[:location] == location }

          controller_number = controller[:number] - 1
          device_number = disk[:device_number]

          disk[:device] = "/dev/#{File.basename(device)}"
          disk[:smart_device] = "aacraid,#{controller_number},0,#{device_number}"

          disk[:arrays] << array[:id]
          disk[:id]
        end
      end
    end
  end

  def find_areca_disks(devices)
    controller = {
      :id => devices[:controllers].count,
      :type => "areca",
      :arrays => [],
      :disks => []
    }

    devices[:controllers] << controller

    IO.popen(%w(/opt/areca/x86_64/cli64 sys info)).each do |line|
      next unless line =~ /^(\S.*\S)\s+:\s+(.*\S)\s*$/

      case Regexp.last_match(1)
      when "Firmware Version" then controller[:firmware_version] = Regexp.last_match(2)
      when "BOOT ROM Version" then controller[:bios_version] = Regexp.last_match(2)
      when "Serial Number" then controller[:serial_number] = Regexp.last_match(2)
      when "Controller Name" then controller[:model] = Regexp.last_match(2)
      end
    end

    path = Dir.glob("/sys/bus/pci/devices/*/host*/scsi_host/host*/host_fw_model").find do |file|
      read_sysctl_file(file) == controller[:model]
    end

    controller[:pci_slot] = File.basename(File.expand_path("#{path}/../../../.."))
    controller[:device] = File.basename(Dir.glob(File.expand_path("#{path}/../../../target0:0:16/0:0:16:0/scsi_generic/*")).first)

    arrays = []

    IO.popen(%w(/opt/areca/x86_64/cli64 vsf info)).each do |line|
      next unless line =~ /^\s+(\d+)\s+/
      array = {
        :id => devices[:arrays].count,
        :number => Regexp.last_match(1),
        :controller => controller[:id],
        :disks => []
      }

      devices[:arrays] << array
      controller[:arrays] << array[:id]

      arrays << array
    end

    arrays.each do |array|
      IO.popen(["/opt/areca/x86_64/cli64", "vsf", "info", "vol=#{array[:number]}"]).each do |line|
        if line =~ /^SCSI Ch\/Id\/Lun\s+:\s+(\d+)\/(\d+)\/(\d+)\s*$/
          pci_slot = controller[:pci_slot]
          channel = Regexp.last_match(1).to_i
          id = Regexp.last_match(2).to_i
          lun = Regexp.last_match(3).to_i

          device = Dir.glob("/sys/bus/pci/devices/#{pci_slot}/host*/target*:0:0/0:#{channel}:#{id}:#{lun}/block/*").first

          array[:device] = "/dev/#{File.basename(device)}"
        elsif line =~ /^Volume State\s+:\s+(.*\S)\s*$/
          case Regexp.last_match(1)
          when "Normal" then array[:status] = "optimal"
          else array[:status] = "unknown"
          end
        elsif line =~ /^(\S.*\S)\s+:\s+(.*\S)\s*$/
          case Regexp.last_match(1)
          when "Volume Set Name" then array[:volume_set] = Regexp.last_match(2)
          when "Raid Set Name" then array[:raid_set] = Regexp.last_match(2)
          when "Volume Capacity" then array[:size] = format_disk_size(Regexp.last_match(2).to_f * 1000 * 1000)
          when "Raid Level" then array[:raid_level] = Regexp.last_match(2).sub(/^Raid/, "")
          end
        end
      end
    end

    disks = []

    IO.popen(%w(/opt/areca/x86_64/cli64 disk info)).each do |line|
      next unless line =~ /^\s+(\d+)\s+.*\s+\d+\.\d+GB\s+(\S.*\S)\s*$/
      next if Regexp.last_match(2) == "N.A."

      disk = {
        :id => devices[:disks].count,
        :number => Regexp.last_match(1),
        :controller => controller[:id],
        :arrays => []
      }

      devices[:disks] << disk
      controller[:disks] << disk[:id]

      if array = arrays.find { |array| array[:raid_set] == Regexp.last_match(2) }
        disk[:arrays] << array[:id]
        array[:disks] << disk[:id]
      end

      disks << disk
    end

    disks.each do |disk|
      IO.popen(["/opt/areca/x86_64/cli64", "disk", "info", "drv=#{disk[:number]}"]).each do |line|
        if line =~ /^IDE Channel\s+:\s+(\d+)\s*$/i
          disk[:smart_device] = "areca,#{Regexp.last_match(1)}"
        elsif line =~ /^Device Location\s+:\s+Enclosure#(\d+) Slot#?\s*0*(\d+)\s*$/i
          disk[:smart_device] = "areca,#{Regexp.last_match(2)}/#{Regexp.last_match(1)}"
        elsif line =~ /^Device State\s+:\s+(.*\S)\s*$/
          case Regexp.last_match(1)
          when "NORMAL" then disk[:status] = "online"
          else disk[:status] = "unknown"
          end
        elsif line =~ /^(\S.*\S)\s+:\s+(.*\S)\s*$/
          case Regexp.last_match(1)
          when "Model Name" then disk[:vendor], disk[:model] = Regexp.last_match(2).split
          when "Serial Number" then disk[:serial_number] = Regexp.last_match(2)
          when "Disk Capacity" then disk[:size] = format_disk_size(Regexp.last_match(2).to_f * 1000 * 1000)
          end
        end
      end
    end
  end

  def lvm_devices
    {
      :pvs => find_lvm_pvs,
      :vgs => find_lvm_vgs,
      :lvs => find_lvm_lvs
    }
  end

  def find_lvm_pvs
    IO.popen(["pvdisplay", "-c"]).each_with_object({}) do |line, pvs|
      fields = line.strip.split(":")

      pvs[fields[0]] = {
        :vg => fields[1],
        :pv_size => fields[2],
        :pv_status => fields[4],
        :pe_size => fields[7],
        :pe_total => fields[8],
        :pe_free => fields[9],
        :pe_allocated => fields[10],
        :pv_uuid => fields[11]
      }
    end
  end

  def find_lvm_vgs
    IO.popen(["vgdisplay", "-c"]).each_with_object({}) do |line, vgs|
      fields = line.strip.split(":")

      vgs[fields[0]] = {
        :vg_access => fields[1],
        :vg_status => fields[2],
        :lv_maximum => fields[4],
        :lv_count => fields[5],
        :lv_open => fields[6],
        :pv_maximum => fields[8],
        :pv_current => fields[9],
        :pv_actual => fields[10],
        :vg_size => fields[11],
        :pe_size => fields[12],
        :pe_total => fields[13],
        :pe_allocated => fields[14],
        :pe_free => fields[15],
        :vg_uuid => fields[16]
      }
    end
  end

  def find_lvm_lvs
    IO.popen(["lvdisplay", "-c"]).each_with_object({}) do |line, lvs|
      fields = line.strip.split(":")

      lvs[fields[0]] = {
        :vg => fields[1],
        :lv_access => fields[2],
        :lv_status => fields[3],
        :lv_open => fields[5],
        :lv_size => fields[6],
        :le_count => fields[7],
        :lv_minor => fields[11],
        :lv_major => fields[12]
      }
    end
  end

  def psu_devices
    device = nil

    IO.popen(["dmidecode", "-t", "39"]).each_with_object([]) do |line, devices|
      if line =~ /^System Power Supply\s*$/
        device = {}
      elsif device && line =~ /^\s+([A-Z ]+):\s+(.*)\s*$/i
        device[Regexp.last_match(1).tr(" ", "_").downcase.to_sym] = Regexp.last_match(2).strip
      elsif device && line =~ /^\s*$/
        devices << device
        device = nil
      end
    end
  end

  def mc_device
    device = {}

    IO.popen(["ipmitool", "mc", "info"]).each_with_object([]) do |line, devices|
      if line =~ /(Manufacturer [A-Z ]+[A-Z])\s*:\s+(.*\S)\s+\(.*\)\s*$/i
        device[Regexp.last_match(1).tr(" ", "_").downcase.to_sym] = Regexp.last_match(2)
      elsif line =~ /(Product [A-Z ]+[A-Z])\s*:\s+(.*\S)\s+\(.*\)\s*$/i
        device[Regexp.last_match(1).tr(" ", "_").downcase.to_sym] = Regexp.last_match(2)
      elsif line =~ /([A-Z ]+[A-Z])\s*:\s+(.*\S)\s*$/i
        device[Regexp.last_match(1).tr(" ", "_").downcase.to_sym] = Regexp.last_match(2)
      end
    end

    IO.popen(["ipmitool", "mc", "guid"]).each_with_object([]) do |line, devices|
      if line =~ /^System GUID\s*:\s+(\S+)\s*$/
        device[:system_guid] = Regexp.last_match(1)
      end
    end

    device
  end

  collect_data(:default) do
    hardware Mash.new

    hardware[:pci] = pci_devices
    hardware[:network] = network_devices
    hardware[:memory] = memory_devices
    hardware[:disk] = disk_devices
    hardware[:lvm] = lvm_devices
    hardware[:psu] = psu_devices
    hardware[:mc] = mc_device
  end
end
